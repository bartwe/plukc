import pluk.io;

class pluk.tag.XmlFormat
{
  private this()
  {
  }

  static void Write(OStream stream, Tag value, bool pretty)
  {
    // Writes the tag tree as a valid UTF-8 xml document.
    // If the output is not valid xml, then that is a bug that needs to be fixed.
    WS(stream, "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
    Write(stream, value, 0, pretty);
  }
  
  static String ToString(Tag value, bool pretty)
  {
    Array<byte> buf;
    scope (var stream = new BufferStream())
    {
      Write(stream, value, pretty);
      buf = new(stream.CountReadable, Byte.FromInt(0));
      stream.Read(buf);
    }
    return Utf8Encoding.GetString(buf);
  } 
  
  static Tag Read(IStream stream)
  {
    XmlReader reader = new(stream);
    return reader.Read();
  }
  
  static Tag FromString(string xml)
  {
    Tag result;
    scope (var stream = new BufferStream())
    {
      stream.Write(Utf8Encoding.GetBytes(xml));
      stream.Close();
      result = Read(stream);
    }
    return result;
  }
  
  static Array<byte> intBuffer = new(0, Byte.FromInt(0));
  static byte[]? smallBuffer;
  
  private static void WS(OStream stream, string value)
  {  
    int length = Utf8Encoding.StringToByteArray(value, intBuffer, 0, 0, false);
    if (length == 0)
      return;
    Array<byte> buffer;
    bool smallBufferUsed = false;
    
    if (length <= 256)
    {
      smallBufferUsed = true;
      if (?smallBuffer)
      {
        buffer = ~smallBuffer;
        smallBuffer = null;
      }
      else
        buffer = new(256, Byte.FromInt(0));
    }
    else
      buffer = new(length, Byte.FromInt(0));
    if (Utf8Encoding.StringToByteArray(value, buffer, 0, length, false) != length)
      throw new IOException("Failed to convert string data to UTF-8.");
    if (stream.Write(buffer, 0, length, length) != length)
      throw new IOException("Failed to write to stream.");
    if (smallBufferUsed)
      smallBuffer = buffer;
  }
  
  private static void WSA(OStream stream, string attributeValue)
  {
    WS(stream, Escape(attributeValue));
  }
  
  private static void WSD(OStream stream, string data)
  {
    WS(stream, Escape(data));
  }
  
  private static string Escape(string value)
  {
    return value.Replace("&", "&amp;").Replace("\"", "&quot;").Replace("<", "&lt;").Replace("'", "&apos;").Replace(">", "&gt;");
  }
  
  private static void Write(OStream stream, Tag value, int depth, bool pretty)
  {
    if (pretty)
    {
      int x = depth;
      while (x > 0)
      {
        WS(stream, " ");
        x = x - 1;
      }
    }
    WS(stream, "<");
    WS(stream, value.Name);
    for (var kv in value.Attributes)
    {
      WS(stream, " ");
      WS(stream, kv.Key);
      WS(stream, "=\"");
      WSA(stream, kv.Value);
      WS(stream, "\"");
    }
    if (!value.Nodes.IsEmpty)
    {
      WS(stream, ">");
      for (var c in value.Nodes)
      {
        if (?c.Data)
          WSD(stream, ~c.Data);
        else
          Write(stream, ~c.Tag, depth + 1, pretty);
      }
      WS(stream, "</");
      WS(stream, value.Name);
      WS(stream, ">");
    }
    else
      WS(stream, "/>");
    if (pretty)
      WS(stream, "\n");
  }
}

class pluk.tag.XmlReader
{
  IStream stream;
  byte zero = Byte.FromInt(0);
  byte sp = Byte.FromInt(32);
  byte lf = Byte.FromInt(10);
  byte cr = Byte.FromInt(13);
  byte lt = Byte.FromInt(60);
  byte gt = Byte.FromInt(62);
  byte eq = byte.FromInt(61);
  byte sl = byte.FromInt(47);
  byte qt = byte.FromInt(34);
  byte que = byte.FromInt(63);
  byte pow = byte.FromInt(33);
  byte dash = byte.FromInt(45);
  byte dee = byte.FromInt(68);
  byte blockopen = byte.FromInt(91);
  byte blockclose = byte.FromInt(93);
  byte peek;
  
  int row = 1;
  int column = 1;
  int offset = 0;
  

  
  this(IStream stream)
  {
    this.stream = stream;
    peek = byte.FromInt(0);
  }
  
  Tag Read()
  {
    // this parser is not validating or even valid
    // it should be able to completely process any xml generated by pluk.tag.XmlFormat.Write, and likely little else
    // feel free to change this code to extend the range of valid xml that can be parsed.
    // make sure to not become less liberal then the current implementation.
    // when mixing child tags and data, whitespace only strings will be removed.
    // only lf is recognized as newline
    peek = zero;
    Node? node = null;
    Tag? result = null;
    while (true)
    {
      node = ReadNode();
      if ((?node) && (?(~node).Tag))
        result = (~node).Tag;
      if (peek == zero)
        break;
    }
    if (!?result)
      throw new Exception("Expected an xml root tag");    
    Tag r = ~result;
    if (peek != zero)
      throw new IOException("End of xml document expected.");
    return r;
  }
  
  private Node? ReadNode()
  {
    Peek();
    if (peek == zero)
      return null;
    ByteArrayBuilder buffer = new();
    if (peek == lt)
    {
      Peek();
      if (peek == sl)
      {
        buffer.Clear();  
        while (true)
        {
          Peek();
          if (peek == zero)
            throw new IOException("Unexpected end of document during reading the name of a tag");
          if ((peek == sp) || (peek == lf) || (peek == gt))
            break;
          buffer.Append(peek);
        }
        if (buffer.Count == 0)
          throw new IOException("Malformed closing tag, empty name not allowed.");
        var name = Utf8Encoding.StringFromByteArray(buffer.GetBuffer(), 0, buffer.Count);
        while ((peek != zero) && (peek != gt))
        {
          Peek();
        }
        return new Node(name, true);
      }
      else if (peek == que)
      {
         byte a = 0;
         while ((peek != zero) && !((a == que) && (peek == gt)))
         {
           a = peek;
           Peek();
         }
         return null;
      }
      else if (peek == pow)
      {
      //doctype
      //comments
      //cdata
      //something
  //    <!DOCTYPE >
  //    <![CDATA[ ]]>
  //    <!-- -->
        Peek();
        if (peek == zero)
          throw new IOException("Unexpected end of document during reading of extended data");
        if (peek == dee)
        {
          while ((peek != zero) && (peek != gt))
            Peek();
        }
        else if (peek == dash)
        {
          byte a = 0;
          byte b = 0;
          while ((peek != zero) && !((a == dash) && (b == dash) && (peek == gt)))
          {
            a = b;
            b = peek;
            Peek();
          }
        }
        else if (peek == blockopen)
        {
          byte a = 0;
          byte b = 0;
          ByteArrayBuilder buffer = new();
          while ((peek != zero) && !((a == blockclose) && (b == blockclose) && (peek == gt)))
          {
            buffer.Append(peek);
            a = b;
            b = peek;
            Peek();
          }
          var cdata = Utf8Encoding.StringFromByteArray(buffer.GetBuffer(), 7, buffer.Count - 9);
          return new Node(cdata);
        }
        else
          throw new IOException("Unexpected data during reading of extended data");
        return null;
      }
      while (true)
      {
        if (peek == zero)
          throw new IOException("Unexpected end of document during reading the name of a tag");
        if ((peek == sp) || (peek == gt) || (peek == sl))
          break;
        buffer.Append(peek);
        Peek();
      }
      if (buffer.Count == 0)
        throw new IOException("Malformed tag, empty name not allowed.");
      var name = Utf8Encoding.StringFromByteArray(buffer.GetBuffer(), 0, buffer.Count);
      var result = new Tag(name);
      while ((peek == sp)||(peek == lf))
      {
        // attribute
        SkipWhitespace();
        if (peek == zero)
          throw new IOException("Unexpected end of document during reading the name of a tag");
        if ((peek == gt) || (peek == sl))
          break;
        buffer.Clear();  
        while (true)
        {
          if (peek == zero)
            throw new IOException("Unexpected end of document during reading the name of a tag");
          if (peek == eq)
            break;
          if ((peek != sp) && (peek != lf))
            buffer.Append(peek);
          Peek();
        }
        if (buffer.Count == 0)
          throw new IOException("Malformed attribute, empty name not allowed.");
        var name = Utf8Encoding.StringFromByteArray(buffer.GetBuffer(), 0, buffer.Count);
        SkipWhitespace();
        if (peek != qt)
          throw new IOException("Malformed attribute, '\"' expected as start of attribute value. "+Describe());
        buffer.Clear();
        Peek();
        while (true)
        {
          if (peek == zero)
            throw new IOException("Unexpected end of document during reading the name of a tag");
          if (peek == qt)
            break;
          buffer.Append(peek);
          Peek();
        }
        var value = Utf8Encoding.StringFromByteArray(buffer.GetBuffer(), 0, buffer.Count);
        result.Attributes.Add(name, Unescape(value));
        Peek();
      }    
      if (peek == sl)
      {
        Peek();
        if (peek != gt)
          throw new IOException("Malformed tag, expected '>' after closing '/'.");
        return new Node(result);
      }
      if (peek == gt)
      {
        while (peek != zero)
        {
          Node? node = ReadNode();
          if (?node)
          {
            var n = ~node;
            if (n.Close)
            {
              if ((~n.Data) != name)
                throw new Exception("Excpected to close tag "+name+" but close tag for "+~n.Data+" "+Describe());
              return new Node(result);
            }
            result.Nodes.Add(n);
          }
        }
        throw new Exception("Expected end of tag: "+name+" "+ Describe());
      }
      throw new IOException("Malformed tag, expected end");
    }
    else
    {
      buffer.Clear();
      while ((peek != zero) && (peek != lt))
      {
        buffer.Append(peek);
        Peek();
      }
      if (peek == lt)
        PushBack(peek);
      var cdata = Utf8Encoding.StringFromByteArray(buffer.GetBuffer(), 0, buffer.Count);
      return new Node(Unescape(cdata));
    }
  }
  
  private string Unescape(string value)
  {
    return value
    .Replace("&bull;", "•")
    .Replace("&lsaquo;", "‹")
    .Replace("&acirc;", "â")
    .Replace("&Acirc;", "Â")
    .Replace("&pound;", "£")
    .Replace("&euro;", "€")
    .Replace("&brvbar;", "¦")
    .Replace("&raquo;", "»")
    .Replace("&copy;", "©")
    .Replace("&quot;", "\"")
    .Replace("&lt;", "<")
    .Replace("&gt;", ">")
    .Replace("&apos;", "'")
    .Replace("&amp;", "&");
  }
  
  private void SkipWhitespace()
  {
    while (true)
    {
      Peek();
      if ((peek == zero) || ((peek != sp) && (peek != lf)))
        break;
    }
  }
  
  Stack<byte> bufferpb = new();
  
  private void PushBack(byte value)
  {
    bufferpb.Push(value);
    offset = offset - 1;
    column = column - 1;
  }
  
  Array<byte> buffer = new(64, Byte.FromInt(0));
  
  private void Peek()
  {
    if (!bufferpb.IsEmpty)
    {
      peek = bufferpb.Pop();
      offset = offset + 1;
      if (peek == lf)
      {
        row = row + 1;
        column = 0;
      }
      else if (peek == cr)
      {
        Peek();
      }
      else
      {
        column = column + 1;
      }
      return;
    }
    var len = stream.Read(buffer, 0, 1, 64);
    
    if (len == -1)
      peek = zero;
    else
    {
      while (len > 0)
      {
        len = len -1;
        bufferpb.Push(buffer[len]);
      }
      Peek();
    }
  }
  
  private string Describe()
  {
    return "row "+row+" column "+column+" offset "+offset+" char "+peek;
  }
  
  private void ReadHeader()
  {
    var expectedHeader = "<?xml version=\"1\" encoding=\"UTF-8\"?>";
    Array<byte> intBuffer = new(0, Byte.FromInt(0));
    int length = Utf8Encoding.StringToByteArray(expectedHeader, intBuffer, 0, 0, false);
    
    Array<byte> buffer = new(length, Byte.FromInt(0));
    if (Utf8Encoding.StringToByteArray(expectedHeader, buffer, 0, length, false) != length)
      throw new IOException("Failed to convert string data to UTF-8.");
    Array<byte> header = new(length, Byte.FromInt(0));
    if (stream.Read(header) != length)
        throw new IOException("Header was not found or malformed.");
    for (var i in 0..length)
      if (header[i] != buffer[i])
        throw new IOException("Header was not recognized.");
  }
}